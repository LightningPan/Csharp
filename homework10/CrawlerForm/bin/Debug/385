<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="referrer" content="origin" />
    <meta property="og:description" content="1、磁盘结构 设备文件：关联至一个设备驱动程序，进而能够与之对应硬件设备进行通信 I/O Ports：I/O 设备地址 一切皆文件：open()，read()，write()，close() 设备类型" />
    <meta http-equiv="Cache-Control" content="no-transform" />
    <meta http-equiv="Cache-Control" content="no-siteapp" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <title>linux 磁盘存储和文件系统 - 我听过 - 博客园</title>
    
    <link rel="stylesheet" href="/css/blog-common.min.css?v=Z9Vw4btcgJmrpUEjY_SgebmTmDXJ_hPFoST7ad2aJp4" />
    <link id="MainCss" rel="stylesheet" href="/skins/blacklowkey/bundle-blacklowkey.min.css?v=_wtKGIz9sYqjm3oTTk7YRXg9g-RHiRw9EHTGXG3FSu8" />
    
    <link id="mobile-style" media="only screen and (max-width: 767px)" type="text/css" rel="stylesheet" href="/skins/blacklowkey/bundle-blacklowkey-mobile.min.css?v=cYvlxMu_nd6MVfg-vi7YqOC6FaZ7VHFsDM166vO_ekA" />
    
    <link type="application/rss+xml" rel="alternate" href="https://www.cnblogs.com/zyybky/rss" />
    <link type="application/rsd+xml" rel="EditURI" href="https://www.cnblogs.com/zyybky/rsd.xml" />
    <link type="application/wlwmanifest+xml" rel="wlwmanifest" href="https://www.cnblogs.com/zyybky/wlwmanifest.xml" />
    <script src="https://common.cnblogs.com/scripts/jquery-2.2.0.min.js"></script>
    <script src="/js/blog-common.min.js?v=98Fvfd6UZH20B_MF08daNaODjSu879MVR9RHmyvWAlg"></script>
    <script>
        var currentBlogId = 579453;
        var currentBlogApp = 'zyybky';
        var cb_enable_mathjax = false;
        var isLogined = false;
        var skinName = 'BlackLowKey';
    </script>
    
    
    
</head>
<body>
    <a name="top"></a>
    
    
<!--done-->
<div id="home">
<div id="header">
	<div id="blogTitle">
        <a id="lnkBlogLogo" href="https://www.cnblogs.com/zyybky/"><img id="blogLogo" src="/skins/custom/images/logo.gif" alt="返回主页" /></a>		
		
<!--done-->
<h1><a id="Header1_HeaderTitle" class="headermaintitle HeaderMainTitle" href="https://www.cnblogs.com/zyybky/">我听过</a>
</h1>
<h2>

</h2>




		
	</div><!--end: blogTitle 博客的标题和副标题 -->
	<div id="navigator">
		
<ul id="navList">
<li><a id="blog_nav_sitehome" class="menu" href="https://www.cnblogs.com/">
博客园</a>
</li>
<li>
<a id="blog_nav_myhome" class="menu" href="https://www.cnblogs.com/zyybky/">
首页</a>
</li>
<li>

<a id="blog_nav_newpost" class="menu" href="https://i.cnblogs.com/EditPosts.aspx?opt=1">
新随笔</a>
</li>
<li>
<a id="blog_nav_contact" class="menu" href="https://msg.cnblogs.com/send/%E6%88%91%E5%90%AC%E8%BF%87">
联系</a></li>
<li>
<a id="blog_nav_rss" class="menu" href="https://www.cnblogs.com/zyybky/rss/">
订阅</a>
<!--<partial name="./Shared/_XmlLink.cshtml" model="Model" /></li>--></li>
<li>
<a id="blog_nav_admin" class="menu" href="https://i.cnblogs.com/">
管理</a>
</li>
</ul>


		<div class="blogStats">
			
			<span id="stats_post_count">随笔 - 
36&nbsp; </span>
<span id="stats_article_count">文章 - 
0&nbsp; </span>
<span id="stats-comment_count">评论 - 
1</span>

			
		</div><!--end: blogStats -->
	</div><!--end: navigator 博客导航栏 -->
</div><!--end: header 头部 -->

<div id="main">
	<div id="mainContent">
	<div class="forFlow">
		<div id="post_detail">
    <!--done-->
    <div id="topics">
        <div class="post">
            <h1 class = "postTitle">
                
<a id="cb_post_title_url" class="postTitle2" href="https://www.cnblogs.com/zyybky/p/12797430.html">linux 磁盘存储和文件系统</a>

            </h1>
            <div class="clear"></div>
            <div class="postBody">
                
<div id="cnblogs_post_body" class="blogpost-body ">
    <p><strong>1、磁盘结构</strong></p>
<p><strong>　　设备文件：关联至一个设备驱动程序，进而能够与之对应硬件设备进行通信</strong><br />　　I/O Ports：I/O 设备地址<br />　　一切皆文件：open()，read()，write()，close()</p>
<p>　　<strong>设备类型：</strong><br />　　块设备：block，存取单位 &ldquo;块&rdquo;，磁盘，支持缓存<br />　　字符设备：char，存取单位 &ldquo;字符&rdquo;，键盘</p>
<p>　　<strong>设备号码：</strong><br />　　　　主设备号：major number，标识设备类型<br />　　　　次设备号：minor number，表示同一类型下的不同设备</p>
<p>　　<strong>磁盘设备的设备文件命名：</strong>/dev/dev_file<br />　　　　SCSI，SATA，SAS，IDE，USB：/dev/sd</p>
<p>　　　　虚拟磁盘：/dev/vd(kvm 技术)、/dev/xvd(xen 技术)</p>
<p>　　　　不同磁盘标识：a-z，aa，bb&hellip;<br />　　　　　　/dev/sda，/dev/sdb&hellip;</p>
<p>　　　　同一设备上的不同分区：1，2&hellip;<br />　　　　　　/dev/sda1，/dev/sda5</p>
<p>　　<strong>硬盘存储术语：</strong><br />　　　　head：磁头<br />　　　　track：磁道<br />　　　　cylinder：柱面<br />　　　　sector：扇区</p>
<div class="cnblogs_code">
<pre># <span style="color: #0000ff;">cat</span> /sys/block/sda/queue/rotational    # <span style="color: #800080;">1</span> 为机械硬盘、<span style="color: #800080;">0</span> 为固态硬盘（针对于直接在物理机上装的 Linux 可以测，虚拟机没用）</pre>
</div>
<p>　　<strong>硬盘存放单位：CHS（磁盘三围）</strong></p>
<p><strong>　　<img src="https://img2020.cnblogs.com/blog/1948815/202004/1948815-20200428181801906-901186427.png" alt="" width="400"></strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>　　每个盘片对应一个磁头（head），每个盘片被化成多个同心圆(track/cylinder)，每个同心圆被切断成多个扇区（sector）。磁盘存储最小单位是 sector</p>
<p>　　采用 24bit 位寻址，其中前10位表示 cylinder（柱面），中间8位表示 head（磁头），后面6位表示 sector（扇区），最大寻址空间8GB。</p>
<p>　　<strong>LBA ( logical block addressing )</strong><br />　　LBA 是一个整数，通过转换成 CHS 格式完成磁盘具体寻址。<br />　　ATA-1 规范中定义了28位寻址模式，以每扇区512位组来计算，ATA-1 所定义的28位 LBA 上限达到128 GiB。2002年 ATA-6 规范采用48位 LBA，同样以每扇区512位组计算容量上限可达128 Petabytes。<br />　　由于 CHS 寻址方式的寻址空间在大概8GB以内，所以在磁盘容量小于大概8GB时，可以使用 CHS 寻址方式或是 LBA 寻址方式，在磁盘容量大于大概8GB时，则只能使用LBA寻址方式。</p>
<p><strong>2、 MBR 和 GPT 分区管理<br /></strong></p>
<p><strong>2.1 为什么分区<br /></strong>　　优化 I/O 性能、实现磁盘空间配额限制、提高修复速度、隔离系统和程序、安装多个 OS、采用不同文件系统</p>
<p><strong>2.2 分区</strong><br />　　两种分区方式：MBR，GPT<br />　　<strong>1&gt; MBR：</strong>Master Boot Record 主引导记录，1982 年，使用 32 位表示扇区数，<strong>分区不超过2T</strong><br />　　　　如何分区：按柱面<br />　　　　0 磁道 0 扇区：512bytes，不属于任何分区（<strong>存取分区元数据</strong>）<br />　　　　　　446bytes：boot loader（主引导程序）<br />　　　　　　64bytes：分区表，其中每 16bytes 标识一个分区<br />　　　　　　2bytes：55AA（标记位），没有 55AA 标记位，认为没有分区</p>
<p>　　　　MBR 分区中一块硬盘最多有 4 个主分区，也可以 3 主分区 + 1 扩展(N 个逻辑分区)</p>
<div class="cnblogs_code">
<pre># hexdump -C -n <span style="color: #800080;">512</span> /dev/sda    # 查看 sda 硬盘的前 <span style="color: #800080;">512</span> 字节</pre>
</div>
<p>　　　　<strong>MBR 分区结构：</strong><br />　　　　硬盘主引导记录 MBR 由 4 个部分组成：<br />　　　　主引|导程序，偏移地址 0000H--0088H , 它负责从活动分区中装载，并运行系统引导程序；<br />　　　　出错信息数据区，偏移地址 0089H--00E1H 为出错信息，00E2H--01BDH 全为 0 字节；<br />　　　　分区表（DPT，Disk Partitioln Table）含 4 个分区项，偏移地址 01BEH--01FDH，每个分区表项长 16 个字节，共 64 字节为分区项 1、分区项 2、 分区项 3、分区项 4；<br />　　　　结束标志字，偏移地址 01FE--01FF 的 2 个字节值为结束标志 55AA。</p>
<p><strong>　　<img src="https://img2020.cnblogs.com/blog/1948815/202004/1948815-20200428183904053-369597252.png" alt="" width="600"></strong></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>　　　　<strong>备份分区表：</strong></p>
<div class="cnblogs_code">
<pre># hexdump -C -n <span style="color: #800080;">512</span> /dev/sda     <span style="color: #008000;"># </span><span style="color: #008000;">查看 sda 硬盘的前 512 字节</span>
# <span style="color: #0000ff;">dd</span> <span style="color: #0000ff;">if</span>=/dev/sda of=/data/dpt bs=<span style="color: #800080;">1</span> count=<span style="color: #800080;">66</span> skip=<span style="color: #800080;">446</span>      <span style="color: #008000;"># </span><span style="color: #008000;">备份分区表（skip 表示跳过 if、seek 跳过 of）</span><span style="color: #000000;">
# hexdump </span>-C /data/dpt           <span style="color: #008000;"># </span><span style="color: #008000;">查看备份分区表</span>
# <span style="color: #0000ff;">dd</span> <span style="color: #0000ff;">if</span>=/dev/zero of=/dev/sda bs=<span style="color: #800080;">1</span> count=<span style="color: #800080;">2</span> seek=<span style="color: #800080;">510</span>       <span style="color: #008000;"># </span><span style="color: #008000;">将 55aa 位清空，模拟破坏分区表</span><span style="color: #000000;">
# hexdump </span>-C -n <span style="color: #800080;">512</span> /dev/sda     <span style="color: #008000;"># </span><span style="color: #008000;">查看 sda 硬盘的前 512 字节，发现已经更改</span>
# fdisk -l /dev/sda              <span style="color: #008000;"># </span><span style="color: #008000;">查看硬盘分区信息</span>
# lsblk                          <span style="color: #008000;"># </span><span style="color: #008000;">查看内存分区表</span>
<span style="color: #0000ff;">dd</span> <span style="color: #0000ff;">if</span>=/data/dpt of=/dev/sda bs=<span style="color: #800080;">1</span> count=<span style="color: #800080;">2</span> skip=<span style="color: #800080;">64</span> seek=<span style="color: #800080;">510 </span># <span style="color: #008000;">恢复 55aa 位</span></pre>
</div>
<p>&nbsp;</p>
<p>　　<strong>2&gt; GPT 分区：</strong><br />　　GPT：GUID ( Globals Unique Identifiers ) partition table 支持 128 个分区，使用 64 位，支持 8Z ( 512Byte/block ) 64Z ( 4096Byte/block )<br />　　使用 128 位 UUID(Universally Unique Identifier)表示磁盘和分区 GPT 分区表，自动备份在头和尾两份，并有 CRC 校验位 uuidgen，生成 UUID。<br />　　UEFI (Unified Extensible Firmware Interface 统一可扩展固件接口)硬件支持 GPT，使操作系统启动。</p>
<p>　　<img src="https://img2020.cnblogs.com/blog/1948815/202004/1948815-20200428185313026-1965552761.png" alt="" width="600"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>　　<strong>BIOS+MBR 和 UEFI+GPT：</strong></p>
<p>　　<img src="https://img2020.cnblogs.com/blog/1948815/202004/1948815-20200428185224903-1825470215.png" alt="" width="600"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p><strong>2.3 管理分区</strong></p>
<p>　　列出块设备：lsblk</p>
<p>　　创建分区使用：<br />　　　　<strong>fdisk&nbsp; 创建 MBR 分区</strong><br /><strong>　　　　gdisk 创建 GPT 分区</strong><br />　　　　<strong>parted 高级分区操作</strong></p>
<p>　　重新设置内存中的内核分区表版本<br />　　　　Partprobe</p>
<p>　　添加硬盘，创建分区：<br />　　不重启电脑识别新添加的硬盘（<strong>echo &lsquo;- - -&rsquo; &gt; /sys/class/scsi_host/host2/scan</strong>）</p>
<div class="cnblogs_code">
<pre>[root@centos6 ~<span style="color: #000000;">]# lsblk
NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sr0 </span><span style="color: #800080;">11</span>:<span style="color: #800080;">0</span> <span style="color: #800080;">1</span> <span style="color: #800080;">4</span>.2G <span style="color: #800080;">0</span><span style="color: #000000;"> rom
sda </span><span style="color: #800080;">8</span>:<span style="color: #800080;">0</span> <span style="color: #800080;">0</span> 20G <span style="color: #800080;">0</span><span style="color: #000000;"> disk
[root@centos6 </span>~]# <span style="color: #0000ff;">echo</span> <span style="color: #800000;">'</span><span style="color: #800000;">- - -</span><span style="color: #800000;">'</span> &gt; /sys/class/scsi_host/host2/scan     <span style="color: #008000;"># </span><span style="color: #008000;">触发磁盘扫描</span>
[root@centos6 ~]# lsblk     <span style="color: #008000;"># </span><span style="color: #008000;">列出所有可用块设备的信息</span>
<span style="color: #000000;">NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT
sr0 </span><span style="color: #800080;">11</span>:<span style="color: #800080;">0</span> <span style="color: #800080;">1</span> <span style="color: #800080;">4</span>.2G <span style="color: #800080;">0</span><span style="color: #000000;"> rom
sda </span><span style="color: #800080;">8</span>:<span style="color: #800080;">0</span> <span style="color: #800080;">0</span> 20G <span style="color: #800080;">0</span><span style="color: #000000;"> disk
sdb </span><span style="color: #800080;">8</span>:<span style="color: #800080;">16</span> <span style="color: #800080;">0</span> 20G <span style="color: #800080;">0</span><span style="color: #000000;"> disk</span></pre>
</div>
<p>　　<strong>parted 命令：</strong>parted 的操作都是实时生效的，小心使用</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">用法：parted [选项]&hellip;[设备 [命令 [参数]&hellip;]]
parted </span>/dev/sdb mklabel gpt|msdos            <span style="color: #008000;"># </span><span style="color: #008000;">创建 GPT 或 MBR 分区</span>
parted /dev/sdb print                        <span style="color: #008000;"># </span><span style="color: #008000;">打印分区表</span>
parted /dev/sdb mkpart primary <span style="color: #800080;">1</span> <span style="color: #800080;">200</span>（默认 M）    <span style="color: #008000;"># </span><span style="color: #008000;">mkpart:分区；primary:全是主分区；起始点和结束点（默认 M）</span>
<span style="color: #000000;">parted </span>/dev/sdb <span style="color: #0000ff;">rm</span> <span style="color: #800080;">1</span>                         <span style="color: #008000;"># </span><span style="color: #008000;">删除分区</span>
parted -l                                    # 列出分区信息</pre>
</div>
<p>　　<strong>分区工具 fdisk 和 gdisk</strong><br />　　分别为 MBR 和 GPT 格式的分区工具</p>
<div class="cnblogs_code">
<pre><span style="color: #000000;"># 子命令：
p 列出分区列表
t 更改分区类型（默认 </span><span style="color: #800080;">83</span><span style="color: #000000;">，swap 82）
n 创建新分区
d 删除分区
v 校验分区
u 转换单位 fdisk </span>-u=cylinders /dev/<span style="color: #000000;">sdb（更改为以扇区分区）
</span><span style="color: #0000ff;">w</span><span style="color: #000000;"> 保存并退出
q 不保存退出<br />
# 查看分区的方式：
</span><span style="color: #0000ff;">cat</span> /proc/<span style="color: #000000;">partitions
lsblk
fdisk </span>-l /dev/sdb     <span style="color: #008000;"># </span><span style="color: #008000;">看到的是真正硬盘的分区表，其他三项看的是内存</span>
ll /dev/sdb*<span style="color: #000000;">
划分分区、更改分区要同步信息到硬盘：（新硬盘分区不会有，旧硬盘更改分区注意 warning）
　　centos6：<br />　　　　partx </span>-a /dev/sda         <span style="color: #008000;"># </span><span style="color: #008000;">增加分区</span>
　　　　partx -d --nr <span style="color: #800080;">6</span> /dev/sda  <span style="color: #008000;"># </span><span style="color: #008000;">删除分区</span>
　　centos5,<span style="color: #800080;">7</span><span style="color: #000000;">：<br />　　　　partprobe
<br />使用 </span><span style="color: #0000ff;">dd</span><span style="color: #000000;"> 命令克隆分区表（只能克隆主分区、扩展分区，逻辑分区不能克隆）
使用 </span><span style="color: #0000ff;">dd</span><span style="color: #000000;"> 命令清空硬盘标记位
数字越小，在越外圈，可以提高优化！</span></pre>
</div>
<p>&nbsp;</p>
<p><strong>3、 管理文件系统</strong></p>
<p><strong>3.1 文件系统</strong><br />　　文件系统是操作系统用于明确存储设备或分区上的文件的方法和数据结构，即<strong>在存储设备上组织文件的方法</strong>。操作系统中负责管理和存储文件信息的软件结构称为文件管理系统，简称文件系统。</p>
<p>　　从系统角度来看，文件系统是<strong>对文件存储设备</strong>的空间进行<strong>组织和分配</strong>，负责文件存储并对存入的文件进行<strong>保护和检索</strong>的系统。具体地说，它负责为用户建立文件，存入、读出、修改、转储文件，控制文件的存取，安全控制，日志，压缩，加密等。</p>
<p><strong>3.2 Linux 文件系统类型：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">支持的文件系统：
</span>/lib/modules/`<span style="color: #0000ff;">uname</span> -r`/kernel/<span style="color: #000000;">fs
</span><span style="color: #0000ff;">df</span> -T     # 查看文件系统类型</pre>
</div>
<p>　　<strong>ext2：</strong>适用于那些分区容量不是太大，<strong>更新也不频繁</strong>的情况，例如 /boot 分区；<br />　　<strong>ext3：</strong>是 ext2 的改进版本，其<strong>支持日志功能</strong>，能够帮助系统从非正常关机导致的异常中恢复。它通常被用作通用的文件系统；<br />　　<strong>ext4：</strong>是 ext 文件系统的最新版。提供了很多新的特性，包括纳秒级时间戳、创建和使用巨型文件(16TB)、最大 1EB 的文件系统，以及速度的提升；<br />　　<strong>SGI 的 xfs：</strong>支持最大 8EB 的文件系统。</p>
<p>　　其他文件系统：btrfs ( Oracle )，reiserfs，jfs ( AIX )，swap</p>
<p>　　光盘：iso9660<br />　　Windows：FAT32，exFAT，NTFS<br />　　Unix：FFS ( fast )，UFS ( unix )，JFS2<br />　　网络文件系统：NFS，CIFS<br />　　集群文件系统：GFS2，OCFS2 ( oracle )<br />　　<strong>分布式文件系统：</strong>fastdfs，ceph，moosefs，mogilefs，glusterfs，Lustre<br />　　RAW：未经处理或者未经格式化产生的文件系统</p>
<p><strong>3.3 创建文件系统</strong><br />　　<strong>文件系统分类：</strong><br />　　根据是否支持 &ldquo;journal&rdquo; 日志功能：<br />　　　　日志型文件系统：ext3，ext4，xfs&hellip;<br />　　　　非日志型文件系统：ext2，vfat</p>
<p>　　<strong>文件系统的组成部分：</strong><br />　　　　内核中的模块：ext4，xfs，vfat<br />　　　　用户空间的管理工具：mkfs.ext4，mkfs.xfs，mkfs.vfat</p>
<p>　　<strong>Linux 的虚拟文件系统：VFS</strong><br />　　　　间接的访问各个文件系统</p>
<p>　　<strong>查看支持的文件系统：cat /proc/filesystems</strong></p>
<p><img src="https://img2020.cnblogs.com/blog/1948815/202004/1948815-20200428195957979-717587984.png" alt="" width="600"></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>　　<strong>创建文件系统：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">mkfs 命令：
mkfs.[ext3</span>|ext4|xfs&hellip;] /dev/<span style="color: #000000;">device
例：<br />mkfs.xfs </span>/dev/sdb1     <span style="color: #008000;"># </span><span style="color: #008000;">将/dev/sdb1 创建为 xfs 的文件系统格式</span>
<br />mkfs -t [ext3|ext4|xfs&hellip;] /dev/<span style="color: #000000;">device
　　</span>-L 'LABEL'     <span style="color: #008000;"># </span><span style="color: #008000;">设定卷标名</span>
blkid /dev/device      <span style="color: #008000;"># </span><span style="color: #008000;">查看文件系统类型</span></pre>
</div>
<p>　　<strong>创建 ext 文件系统：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">mke2fs：ext 系列文件系统专用管理工具
　　</span>-t [ext2|ext3|<span style="color: #000000;">ext4] 指定文件系统类型
　　</span>-b [<span style="color: #800080;">1024</span>|<span style="color: #800080;">2048</span>|<span style="color: #800080;">4096</span><span style="color: #000000;">] 指定块大小为 1K，2K，4K
每创建一个文件不论大小以块为单位分配
<br /></span>　　-<span style="color: #000000;">L 'LABEL'  设置卷标名
　　</span>-<span style="color: #000000;">f          重新格式化
　　</span>-j          相当于 -<span style="color: #000000;">t ext3
　　　　mkfs.ext3 </span>= mkfs -t ext3 = mke2fs -j = mke2fs -<span style="color: #000000;">t ext3
　　</span>-<span style="color: #000000;">i          为数据空间中每多少个字节创建一个 inode，不应该小于 block 大小
　　</span>-<span style="color: #000000;">N          指定分区中创建多少个 inode
　　</span>-I          一个 inode 记录占用的磁盘空间大小，<span style="color: #800080;">128</span>&mdash;<span style="color: #800080;">4096</span>
　　-m          指定为管理员预留的空间，默认为 <span style="color: #800080;">5</span>%
　　-<span style="color: #000000;">O FEATURE  启用指定特性
　　</span>-O ^<span style="color: #000000;">FEATURE 关闭指定特性<br />
把连续的块组合成组，每个组有自己节点表</span></pre>
</div>
<p>　　<strong>文件系统标签：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">指向设备的另一种方法，与设备无关
blkid：块设备属性信息查看
　　</span>-<span style="color: #000000;">U UUID  根据指定的 UUID 来查找对应的设备
　　</span>-<span style="color: #000000;">L LABEL 根据指定的 LABEL 来查找对应的设备
e2label：管理 ext 系列文件系统的 LABEL
e2label </span>/dev/device [LABEL]     <span style="color: #008000;"># </span><span style="color: #008000;">指定卷标名</span>
<span style="color: #000000;">findfs：查找分区
findfs UUID</span>=<span style="color: #000000;">XXX
findfs LABEL</span>=XXX</pre>
</div>
<p>　　<strong>超级块和 INODE TABLE：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">tune2fs：重新设定 ext 系列文件系统可调整参数的值
　　</span>-<span style="color: #000000;">l 查看指定文件系统超级块信息；super block
　　</span>-<span style="color: #000000;">L 'LABEL'  修改卷标名
　　</span>-<span style="color: #000000;">m          修改预留给管理员的空间百分比
　　</span>-<span style="color: #000000;">j          将 ext2 升级为 ext3
　　</span>-O          文件系统属性启用或禁用，-O ^<span style="color: #000000;">has_journal（启用日志）
　　</span>-o          调整文件系统的默认挂载选项，-o ^<span style="color: #000000;">acl
　　</span>-<span style="color: #000000;">U UUID     修改 UIID 号（UUID 使用 uuidgen 命令生成）
<br />dumpe2fs：显示 ext 文件系统信息，将磁盘分组管理
　　</span>-h          查看超级块信息，不显示分组信息相当于 tune2fs -<span style="color: #000000;">l
<br />xfs_info：显示已挂载的文件系统信息</span></pre>
</div>
<p>　　<strong>文件系统故障常发生于死机或非正常关机，挂载为文件系统标记 "no clean"</strong><br />　　<strong>注意：一定不要在挂载状态下执行修复！</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;">fsck.FS_TYPE
fsck </span>-<span style="color: #000000;">t FS_TYPE
注意：FS_TYPE 一定要与分区上文件类型相同
　　</span>-<span style="color: #000000;">a 自动修复
　　</span>-<span style="color: #000000;">r 交互式修复错误
<br />e2fsck：ext 系列文件专用的检测修复工具
　　</span>-<span style="color: #000000;">y 自动回答为 yes
　　</span>-<span style="color: #000000;">f 强制修复
　　</span>-<span style="color: #000000;">p 自动进行安全的修复文件系统问题
<br />xfs_repair：xfs 文件系统专用检测修复工具
　　</span>-<span style="color: #000000;">f 修复文件，设备不修复
　　</span>-<span style="color: #000000;">n 只检查
　　</span>-d 允许修复只读的挂载设备，在单用户下修复时使用，然后立即 reboot</pre>
</div>
<p>&nbsp;</p>
<p><strong>4、挂载设备</strong></p>
<p><strong>4.1 挂载 mount、卸载 umount</strong><br />　　挂载：将额外文件系统与根文件系统某现存的目录建立起关联关系，进而使得目录作为其他文件访问入口的行为<br />　　卸载：为解除此关联关系的过程</p>
<p>　　挂载点下原有文件在挂载完成后会被临时隐藏，挂载点目录一般为空。</p>
<p>　　伪文件系统名称：proc，sysfs，devtmpfs，configfs</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">mount</span> device <span style="color: #0000ff;">dir</span><span style="color: #000000;">
　　device：指明要挂载的设备
　　</span><span style="color: #0000ff;">dir</span><span style="color: #000000;">：挂载点
　　　　事先存在，建议使用空目录
　　　　进程正在使用的设备无法被卸载
　　默认挂载可读可写<br /></span><span style="color: #0000ff;"><br />mount</span> -r:只读挂载<br /><span style="color: #0000ff;">mount</span> -o remount,[rw|<span style="color: #000000;">ro]:取消挂载
<br /></span>/etc/mtab                  <span style="color: #008000;"># </span><span style="color: #008000;">挂载信息实时更新</span>
<span style="color: #0000ff;">mount</span> -L 'LACEL' /mnt/sdb1 <span style="color: #008000;"># </span><span style="color: #008000;">以卷标的方式挂载</span>
<span style="color: #0000ff;">mount</span> -U 'UUID'            <span style="color: #008000;"># </span><span style="color: #008000;">以 UUID 挂载</span>
　　-<span style="color: #000000;">B 绑定目录到另一个目录上
　　</span>-<span style="color: #000000;">t 指明要挂载的设备上的文件系统类型（默认不用写）
　　</span>-<span style="color: #000000;">r readonly 只读挂载
　　</span>-<span style="color: #0000ff;">w</span> read and <span style="color: #0000ff;">write</span><span style="color: #000000;"> 读写挂载
　　</span>-n 不更新/etc/mtab，<span style="color: #0000ff;">mount</span><span style="color: #000000;"> 不可见 隐藏挂载，centos7 不支持
　　</span>-a 自动挂载所有支持自动挂载的设备（定义在了/etc/<span style="color: #000000;">fstab 文件中，且挂载选项中有 auto 功能）
<br />查看内核追踪到的已挂载的所有设备：
　　</span><span style="color: #0000ff;">cat</span> /proc/<span style="color: #000000;">mounts
同一挂载点同一时间只能挂载一个；可以将一个设备挂载到多个挂载点。
也可以将文件挂载至文件夹（将文件先格式化成特定的文件系统）centos6 上挂载时要加 </span>-<span style="color: #000000;">o loop 选项 相当于 U 盘
losetup </span>-a      <span style="color: #008000;"># </span><span style="color: #008000;">显示 loop 设备分配</span>
<span style="color: #0000ff;">ls</span> /dev/loop*   <span style="color: #008000;"># </span><span style="color: #008000;">显示 loop 设备</span>
brw-rw----. <span style="color: #800080;">1</span> root disk <span style="color: #800080;">7</span>, <span style="color: #800080;">0</span> <span style="color: #800080;">2</span> 月 <span style="color: #800080;">13</span> <span style="color: #800080;">11</span>:<span style="color: #800080;">23</span> /dev/<span style="color: #000000;">loop0
brw</span>-rw----. <span style="color: #800080;">1</span> root disk <span style="color: #800080;">7</span>, <span style="color: #800080;">1</span> <span style="color: #800080;">2</span> 月 <span style="color: #800080;">13</span> <span style="color: #800080;">11</span>:<span style="color: #800080;">23</span> /dev/<span style="color: #000000;">loop1
brw</span>-rw----. <span style="color: #800080;">1</span> root disk <span style="color: #800080;">7</span>, <span style="color: #800080;">2</span> <span style="color: #800080;">2</span> 月 <span style="color: #800080;">13</span> <span style="color: #800080;">11</span>:<span style="color: #800080;">23</span> /dev/<span style="color: #000000;">loop2
&hellip;&hellip;
centos 6 只有 </span><span style="color: #800080;">0</span>-<span style="color: #800080;">7</span> <span style="color: #800080;">8</span><span style="color: #000000;"> 个设备，centos7 没限制
</span><span style="color: #0000ff;">mknod</span> /dev/loop100 b <span style="color: #800080;">7</span> <span style="color: #800080;">100</span>        <span style="color: #008000;"># </span><span style="color: #008000;">临时创建设备，100 是编号</span>
编辑/boot/grub/grub.conf 文件，再 kernel 后加上 max_loop=<span style="color: #800080;">100</span><span style="color: #000000;">，重启生成 </span><span style="color: #800080;">100</span><span style="color: #000000;"> 个 loop 设备
losetup </span>/dev/loop66 /data/disk    # 关联 loop 设备再挂载</pre>
</div>
<p><strong>4.2 mount 常用选项</strong></p>
<div class="cnblogs_code">
<pre>-<span style="color: #000000;">o options : (挂载文件系统的选项)，多个选项使用逗号分隔
　　async异步模式          sync同步模式，内存更改时，同时写磁盘
　　atime</span>/<span style="color: #000000;">noatime         包含目录和文件
　　diratime</span>/<span style="color: #000000;">nodiratime   目录的访问时间戳
　　auto</span>/noauto           是否支持自动挂载，是否支持-<span style="color: #000000;">a选项
　　exec</span>/<span style="color: #000000;">noexec           是否支持将文件系统上运行应用程序
　　dev</span>/<span style="color: #000000;">nodev             是否支持在此文件系统上使用设备文件
　　suid</span>/<span style="color: #000000;">nosuid           是否支持suid和sgid权限
　　remount               重新挂载
　　ro只读                 rw读写
　　user</span>/nouser           是否允许普通用户挂载此设备，/etc/<span style="color: #000000;">fstab 使用
　　acl                   启用此文件系统上的ac</span>|<span style="color: #000000;">功能
　　loop                  使用loop设备
defaults：相当于rw, suid, dev, exec, auto, nouser, async</span></pre>
</div>
<p><strong>4.3 持久挂载和 swap 空间管理</strong></p>
<p>　　fuser 可以显示出当前哪个程序在使用磁盘上的某个文件、挂载点、甚至网络端口，并给出程序进程的详细信息。<br />　　fuser 显示使用指定文件或者文件系统的进程 ID。</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;"># yum</span> <span style="color: #0000ff;">install</span> psmisc -y     <span style="color: #008000;"># </span><span style="color: #008000;">安装 fuser</span>
# <span style="color: #0000ff;">fuser</span> -v /mnt/sdb1        <span style="color: #008000;"># </span><span style="color: #008000;">查看谁正在使用该文件夹，请进一步了解 fuser 命令的用法</span>
/mnt/sdb1: root kernel <span style="color: #0000ff;">mount</span> /mnt/<span style="color: #000000;">sdb1
           root </span><span style="color: #800080;">1245</span><span style="color: #000000;">   ..c.. bash
# </span><span style="color: #0000ff;">fuser</span> -km /mnt/sdb1       <span style="color: #008000;"># </span><span style="color: #008000;">强制杀掉该目录使用的用户进程</span></pre>
</div>
<p>　　<strong>查看挂载情况：</strong></p>
<div class="cnblogs_code">
<pre># findmnt /mnt/sdb1         <span style="color: #008000;"># </span><span style="color: #008000;">df 显示不了隐藏的挂载，使用 findmnt 查询该目录是否为挂载点</span>
<span style="color: #000000;">
# 查看正在访问指定文件系统的进程：
# lsof </span>/boot                <span style="color: #008000;"># </span><span style="color: #008000;">也能看到是否有人使用该目录（挂载点）</span>
# <span style="color: #0000ff;">fuser</span> -v /mnt/sdb1        <span style="color: #008000;"># </span><span style="color: #008000;">也可以</span>
<br /><span style="color: #000000;"># 终止所有正在指定的文件系统的进程：
# </span><span style="color: #0000ff;">fuser</span> -km /mnt/sdb1</pre>
</div>
<p>　　<strong>挂载点和 /etc/fstab</strong><br />　　　　配置文件系统体系<br />　　　　被 mount、fsck 和其他程序使用<br />　　　　系统重启时保留文件系统体系<br />　　　　可以在设备栏使用文件系统卷标</p>
<p>　　<strong>文件挂载配置文件：</strong><br />　　　　/etc/fstab 每行定义一个要挂载的文件系统<br />　　　　<strong>要挂载的设备或伪文件系统：</strong><br />　　　　设备文件：LABEL：LABEL=卷标名<br />&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UUID：UUID=uuid<br />　　　　 &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;伪文件系统名称：proc，sysfs</p>
<p>　　　　<strong>挂载点</strong></p>
<p>　　　　<strong>文件系统类型：</strong>ext4，xfs，iso9660，nfs，none</p>
<p>　　　　<strong>挂载选项：</strong>defaults，acl，bind<br />　　　　　　使用 <strong>mount -a</strong> 命令挂载 /etc/fstab 中的所有文件系统，使配置文件生效</p>
<p>　　　　<strong>转储频率：</strong>0：不做备份 &nbsp; 1：每天转储 &nbsp; 2：每隔一天转储</p>
<p>　　　　<strong>fsck 检查的文件系统的顺序：</strong>0：不自检&nbsp;&nbsp; 1：首先自检 &nbsp; 2：非 rootfs 使用</p>
<p>　　　　<strong>注意：</strong>mount -a 针对于刚挂载的，加载使生效；对于已经挂载的，更改属性值后使用 mount -a 不管用，使用 <strong>mount -o remount /mnt/sdb1</strong>。</p>
<p>　　<strong>处理交换文件和分区：</strong></p>
<p>　　swap 交换分区是系统 RAM 的补充，<strong>swap 分区支持虚拟内存</strong>，当没有足够的RAM 保存系统处理的数据时会将数据写入 swap 分区。<br />　　当系统缺乏 swap 空间时，内核会因 RAM 内存耗尽而终止进程。配置过多 swap 空间会造成存储设备处于分配状态但闲置，造成浪费，过多 swap 空间还会掩盖内存泄露。<br />　　<strong>推荐系统 swap 空间：</strong></p>
<p>　　<img src="https://img2020.cnblogs.com/blog/1948815/202004/1948815-20200428210708154-1390430480.png" alt="" width="600"></p>
<p>&nbsp;</p>
<p>　　<strong>设置增加 swap 大小，至于磁盘外侧（访问快）</strong></p>
<div class="cnblogs_code">
<pre>1.新添硬盘，分区 <span style="color: #800080;">1</span>（于磁盘外侧）；分配大小完毕，t <span style="color: #800080;">82</span><span style="color: #000000;"> 设置 swap 格式分区。
2.mkswap </span>/dev/sdc1     <span style="color: #008000;"># </span><span style="color: #008000;">格式化（swap 格式使用 mkswap 格式化）</span>
3.写入/etc/fatab 文件，swap 挂载到 swap；默认值更改为 pri=<span style="color: #800080;">10</span><span style="color: #000000;">（优先级）
4.swapon </span>-a            <span style="color: #008000;"># </span><span style="color: #008000;">使 swap 格式配置文件生效</span>
5.swapon -s            <span style="color: #008000;"># </span><span style="color: #008000;">相当于 cat /proc/swaps，</span><span style="color: #008000;">查看 swap 分区信息</span>
<br />swapoff /dev/sdc1      <span style="color: #008000;"># </span><span style="color: #008000;">关闭 swapon -a </span><span style="color: #008000;">开启</span>
<span style="color: #0000ff;">free</span> -h                <span style="color: #008000;"># </span><span style="color: #008000;">查看内存和 swap 信息</span>
增加文件 swap 分区，<span style="color: #0000ff;">dd</span><span style="color: #000000;"> 设置大文件（swap 只能写文件名），删除的话：关闭，改文件</span></pre>
</div>
<p>　　<strong>swap 的优先级：</strong></p>
<p>　　可以指定 swap 分区 <strong>0到32767</strong> 的优先级，<strong>值越大优先级越高</strong>。<br />　　如果用户没有指定，那么核心会自动给 swap 指定一个优先级，这个优先级从-1开始，每加入一个新的没有用户指定优先级的 swap，会给这个优先级减一。<br />　　先添加的 swap 的缺省优先级比较高，除非用户自己指定一个优先级，而用户指定的优先级(是正数)永远高于核心缺省指定的优先级(是负数)。<br />　　优化性能：分布存放，高性能磁盘存放。</p>
<p>　　<strong>文件夹挂载文件夹：</strong><br />　　　　文件类型：none bind 0 0<br />　　<strong>挂载光盘：</strong><br />　　　　/dev/sr0 /mnt/cdrom iso9660 defaults 0 0</p>
<p><strong>　　挂载网络服务：</strong>nfs，samba</p>
<p>　　<strong>迁移 home 目录到新分区：</strong><br />　　　　建议 init 1 进入<strong>单用户模式</strong>，防止别人正在使用文件（要确保别人不访问）<br />　　　　新建 /mnt/home 目录，将新分区(格式化)挂载至该目录<br />　　　　cp -a /home/. /mnt/home/<br />　　　　再将新分区挂载到 /home 目录</p>
<p><strong>4.4 移动介质</strong></p>
<p>　　挂载意味着使外来的文件系统看起来如同是主目录树的一部分<br />　　　　访问前，介质必须被挂载<br />　　　　摘除时，介质必须被卸载<br />　　按照默认设置，非根用户只能挂载某些设备（光盘、DVD、软盘、USB 等）<br />　　挂载点通常在 /media 或 /mnt 下</p>
<p>　　<strong>使用光盘：</strong></p>
<div class="cnblogs_code">
<pre>在图形环境下自动启动挂载 /run/media/&lt;user&gt;/&lt;label&gt;<span style="color: #000000;">
否则必须手动挂载：<br /></span><span style="color: #0000ff;">mount</span> /dev/cdrom /mnt/cdrom</pre>
</div>
<p>　　<strong>操作光盘：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">eject</span><span style="color: #000000;">    弹出光盘
</span><span style="color: #0000ff;">eject</span> -t 弹入光盘</pre>
</div>
<p>　　<strong>创建 ISO 文件：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;"># cp</span> /dev/cdrom /root/<span style="color: #000000;">centos.iso
# mkisofs </span>-r -o /root/etc.iso /etc   # /将/etc 目录打包成 iso 文件</pre>
</div>
<p>　　<strong>挂载 ISO 文件（ISO 文件只读）</strong></p>
<p>　　<strong>刻录光盘：</strong></p>
<div class="cnblogs_code">
<pre>wodim -v -<span style="color: #0000ff;">eject</span> centos.iso</pre>
</div>
<p>　　<strong>挂载 USB 介质</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #000000;"># lsusb     # <span style="color: #000000;">查看 USB 设备是否识别</span>
# </span><span style="color: #0000ff;">lsmod</span>     <span style="color: #008000;"># </span><span style="color: #008000;">查看正在使用的内核</span>
<span style="color: #000000;">
被内核探测为 SCSI 设备
　　</span>/dev/sdaX、/dev/<span style="color: #000000;">sdbX 或类似的设备文件

在图形环境中自动挂载：
　　图标在[计算机]窗口创建
　　挂载</span>/run/media/&lt;user&gt;/&lt;label&gt;<span style="color: #000000;">

手动挂载：
# </span><span style="color: #0000ff;">mount</span> /dev/sdb1 /mnt</pre>
</div>
<p>&nbsp;</p>
<p><strong>4.5 常见工具</strong></p>
<p>　　<strong>文件系统空间占用等信息的查看工具：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">df</span><span style="color: #000000;"> [OPTION]&hellip; [FILE]&hellip;
　　</span>-H 以 <span style="color: #800080;">10</span><span style="color: #000000;"> 为单位
　　</span>-<span style="color: #000000;">T 文件系统类型
　　</span>-h human-<span style="color: #000000;">readable
　　</span>-<span style="color: #000000;">i inodes instead of blocks
　　</span>-P 以 Posix 兼容的格式输出</pre>
</div>
<p>　　<strong>查看某目录总体空间占用状态：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">du</span><span style="color: #000000;"> [OPTION]&hellip; DIR
　　</span>-h human-<span style="color: #000000;">readble
　　</span>-<span style="color: #000000;">s summary
　　</span>-max-depth=# 指定最大目录层级</pre>
</div>
<p>　　<strong>dd 命令：convert and copy a file（转换并复制文件）</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">dd</span> <span style="color: #0000ff;">if</span>=/PATH/FROM/SRC of=/PATH/TO/DEST bs=# count=<span style="color: #000000;">#
　　</span><span style="color: #0000ff;">if</span>=<span style="color: #0000ff;">file      </span><span style="color: #000000;"> 从所命令文件读取而不是从标准输入
　　of</span>=<span style="color: #0000ff;">file</span><span style="color: #000000;">       写到所命令的文件而不是到标准输出
　　ibs</span>=size      一次读 size 个 <span style="color: #0000ff;">byte</span><span style="color: #000000;">
　　obs</span>=size      一次写 size 个 <span style="color: #0000ff;">byte</span><span style="color: #000000;">
　　bs</span>=<span style="color: #000000;">size       block size，指定块大小（即是 ibs 也是 obs）
　　cbs</span>=size      一次转化 size 个 <span style="color: #0000ff;">byte</span><span style="color: #000000;">
　　skip</span>=<span style="color: #000000;">blocks   从开头忽略 blocks 个 ibs 大小的块
　　seek</span>=blocks   从开头忽略 blocks 个 obs 大小的块<br />　　count=n       复制 n 个 bs</pre>
</div>
<p>&nbsp;</p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;">echo</span> {<span style="color: #800080;">0</span>..<span style="color: #800080;">9</span>} | <span style="color: #0000ff;">tr</span> -d <span style="color: #800000;">'</span> <span style="color: #800000;">'</span> &gt; /test/<span style="color: #000000;">f1.txt
</span><span style="color: #0000ff;">echo</span> {a..z} | <span style="color: #0000ff;">tr</span> -d <span style="color: #800000;">'</span> <span style="color: #800000;">'</span> &gt; /test/<span style="color: #000000;">f2.txt
</span><span style="color: #0000ff;">dd</span> <span style="color: #0000ff;">if</span>=/test/f1.txt of=/test/f2.txt bs=<span style="color: #800080;">1</span> skip=<span style="color: #800080;">2</span> seek=<span style="color: #800080;">3</span> count=<span style="color: #800080;">4</span>
<span style="color: #0000ff;">cat</span> /test/<span style="color: #000000;">f2.txt
abc2345     </span><span style="color: #008000;"># </span><span style="color: #008000;">默认截断之后的数，要想不截断使用 conv</span>
<span style="color: #0000ff;">echo</span> {a..z} | <span style="color: #0000ff;">tr</span> -d <span style="color: #800000;">'</span> <span style="color: #800000;">'</span> &gt; /test/<span style="color: #000000;">f2.txt
</span><span style="color: #0000ff;">dd</span> <span style="color: #0000ff;">if</span>=/test/f1.txt of=/test/f2.txt bs=<span style="color: #800080;">1</span> skip=<span style="color: #800080;">2</span> seek=<span style="color: #800080;">3</span> count=<span style="color: #800080;">4</span> conv=<span style="color: #000000;">notrunc
</span><span style="color: #0000ff;">cat</span> /test/<span style="color: #000000;">f2.txt
abc2345hijklmnopqrstuvwxyz
conv</span>=<span style="color: #000000;"> conversion[,conversion...] 用指定的参数转换文件
转换参数：
　　ascii      转换 EBCDIC 为 ASCII
　　ebcdic     转换 ASCII 为 EBCDIC
　　Icase      把大写字符转换为小写字符
　　ucase      把小写字符转换为大写字符
　　nocreat    不创建输出文件
　　noerror    出错时不停止
　　notrunc    不截短输出文件
　　</span><span style="color: #0000ff;">sync</span><span style="color: #000000;">       把每个输入块填充到 ibs 个字节,不足部分用空(NUL)字符补齐
　　fdatasync  写完成前,物理写入输出文件</span></pre>
</div>
<p>&nbsp;</p>
<p>　　<strong>使用 dd 命令备份 MBR 分区表：</strong></p>
<div class="cnblogs_code">
<pre><span style="color: #0000ff;"># 使用 dd 命令备份 MBR 分区表：<br /># dd</span> <span style="color: #0000ff;">if</span>=/dev/sda of=/tmp/mbr.bak bs=<span style="color: #800080;">512</span> count=<span style="color: #800080;">1</span><span style="color: #000000;">
<br /># 破坏 MBR 中的 bootloader
# </span><span style="color: #0000ff;">dd</span> <span style="color: #0000ff;">if</span>=/dev/zero of=/dev/sda bs=<span style="color: #800080;">64</span> count=<span style="color: #800080;">1</span> seek=<span style="color: #800080;">446</span><span style="color: #000000;">
<br /># 备份：
# </span><span style="color: #0000ff;">dd</span> <span style="color: #0000ff;">if</span>=/dev/sdx of=/dev/<span style="color: #000000;">sdy                  # <span style="color: #000000;">将本地的/dev/sdx 整盘备份到/dev/<span style="color: #000000;">sdy</span></span>
</span><span style="color: #000000;"># </span><span style="color: #0000ff;">dd</span> <span style="color: #0000ff;">if</span>=/dev/sdx of=/path/to/<span style="color: #000000;">image            # <span style="color: #000000;">将/dev/<span style="color: #000000;">sdx 全盘数据备份到指定路径的 image 文件</span></span></span><span style="color: #000000;">
# </span><span style="color: #0000ff;">dd</span> <span style="color: #0000ff;">if</span>=/dev/sdx | <span style="color: #0000ff;">gzip</span> &gt; /path/to/<span style="color: #000000;">image.gz   # <span style="color: #000000;">备份/dev/sdx 全盘数据，并利用 <span style="color: #0000ff;">gzip<span style="color: #000000;"> 压缩，保存到指定路径</span></span></span>
</span><span style="color: #000000;">
# 恢复：
# </span><span style="color: #0000ff;">dd</span> <span style="color: #0000ff;">if</span>=/path/to/image of=/dev/<span style="color: #000000;">sdx            # <span style="color: #000000;">将备份文件恢复到指定盘</span>
# </span><span style="color: #0000ff;">gzip</span> -dc /path/to/image.gz | <span style="color: #0000ff;">dd</span> of=/dev/<span style="color: #000000;">sdx # <span style="color: #000000;">将压缩的备份文件恢复到指定盘</span>

# 拷贝内存资料到硬盘
# </span><span style="color: #0000ff;">dd</span> <span style="color: #0000ff;">if</span>= /dev/mem of=/root/mem.bin bs= <span style="color: #800080;">1024   # <span style="color: #000000;">将内存里的数据拷贝到 root 目录下的 mem.bin 文件</span></span><span style="color: #000000;">
<br /># 从光盘拷贝 iso 镜像
</span><span style="color: #0000ff;">dd</span> <span style="color: #0000ff;">if</span>= /dev/cdrom of=/root/<span style="color: #000000;">cd.iso             # <span style="color: #000000;">拷贝光盘数据到 root 文件夹下,并保存为 cd.iso 文件</span>
<br /># 销毁磁盘数据
</span><span style="color: #0000ff;">dd</span> <span style="color: #0000ff;">if</span>=/dev/urandom of=/dev/<span style="color: #000000;">sda1
利用随机的数据填充硬盘，在某些必要的场合可以用来销毁数据，执行此操作以后，</span>/dev/sda1 将无法挂载，创建和拷贝操作无法执行。</pre>
</div>
<p>&nbsp;</p>
</div>
<div id="MySignature"></div>
<div class="clear"></div>
<div id="blog_post_info_block">
    <div id="blog_post_info"></div>
    <div class="clear"></div>
    <div id="post_next_prev"></div>
</div>
            </div>
            <div class="postDesc">posted @ 
<span id="post-date">2020-04-28 21:38</span>&nbsp;
<a href="https://www.cnblogs.com/zyybky/">我听过</a>&nbsp;
阅读(<span id="post_view_count">...</span>)&nbsp;
评论(<span id="post_comment_count">...</span>)&nbsp;
<a href="https://i.cnblogs.com/EditPosts.aspx?postid=12797430" rel="nofollow">编辑</a>&nbsp;
<a href="javascript:void(0)" onclick="AddToWz(12797430);return false;">收藏</a></div>
        </div>
	    
	    
    </div><!--end: topics 文章、评论容器-->
</div>
<script src="https://common.cnblogs.com/highlight/9.12.0/highlight.min.js"></script>
<script>markdown_highlight();</script>
<script>
    var allowComments = true, cb_blogId = 579453, cb_blogApp = 'zyybky', cb_blogUserGuid = 'd78335f5-e8ea-4df5-16c5-08d7b5fb2c66';
    var cb_entryId = 12797430, cb_entryCreatedDate = '2020-04-28 21:38', cb_postType = 1; 
    loadViewCount(cb_entryId);
    loadSideColumnAd();
</script><a name="!comments"></a>
<div id="blog-comments-placeholder"></div>
<script>
    var commentManager = new blogCommentManager();
    commentManager.renderComments(0);
</script>

<div id="comment_form" class="commentform">
    <a name="commentform"></a>
    <div id="divCommentShow"></div>
    <div id="comment_nav"><span id="span_refresh_tips"></span><a href="javascript:void(0);" onclick="return RefreshCommentList();" id="lnk_RefreshComments" runat="server" clientidmode="Static">刷新评论</a><a href="#" onclick="return RefreshPage();">刷新页面</a><a href="#top">返回顶部</a></div>
    <div id="comment_form_container"></div>
    <div class="ad_text_commentbox" id="ad_text_under_commentbox"></div>
    <div id="ad_t2"></div>
    <div id="opt_under_post"></div>
    <script async="async" src="https://www.googletagservices.com/tag/js/gpt.js"></script>
    <script>
        var googletag = googletag || {};
        googletag.cmd = googletag.cmd || [];
    </script>
    <script>
        googletag.cmd.push(function () {
            googletag.defineSlot("/1090369/C1", [300, 250], "div-gpt-ad-1546353474406-0").addService(googletag.pubads());
            googletag.defineSlot("/1090369/C2", [468, 60], "div-gpt-ad-1539008685004-0").addService(googletag.pubads());
            googletag.pubads().enableSingleRequest();
            googletag.enableServices();
        });
    </script>
    <div id="cnblogs_c1" class="c_ad_block">
        <div id="div-gpt-ad-1546353474406-0" style="height:250px; width:300px;"></div>
    </div>
    <div id="under_post_news"></div>
    <div id="cnblogs_c2" class="c_ad_block">
        <div id="div-gpt-ad-1539008685004-0" style="height:60px; width:468px;">
            <script>
                if (new Date() >= new Date(2018, 9, 13)) {
                    googletag.cmd.push(function () { googletag.display("div-gpt-ad-1539008685004-0"); });
                }
            </script>
        </div>
    </div>
    <div id="under_post_kb"></div>
    <div id="HistoryToday" class="c_ad_block"></div>
    <script type="text/javascript">
        fixPostBody();
        deliverBigBanner();
setTimeout(function() { incrementViewCount(cb_entryId); }, 50);        deliverAdT2();
        deliverAdC1();
        deliverAdC2();
        loadNewsAndKb();
        loadBlogSignature();
LoadPostCategoriesTags(cb_blogId, cb_entryId);        LoadPostInfoBlock(cb_blogId, cb_entryId, cb_blogApp, cb_blogUserGuid);
        GetPrevNextPost(cb_entryId, cb_blogId, cb_entryCreatedDate, cb_postType);
        loadOptUnderPost();
        GetHistoryToday(cb_blogId, cb_blogApp, cb_entryCreatedDate);
    </script>
</div>
	</div><!--end: forFlow -->
	</div><!--end: mainContent 主体内容容器-->

	<div id="sideBar">
		<div id="sideBarMain">
			
<div id="sidebar_news" class="newsItem">
            <script>loadBlogNews();</script>
</div>

<div id="sidebar_ad"></div>
			<div id="blog-calendar" style="display:none"></div><script>loadBlogDefaultCalendar();</script>
			
			<div id="leftcontentcontainer">
				<div id="blog-sidecolumn"></div>
                    <script>loadBlogSideColumn();</script>
			</div>
			
		</div><!--end: sideBarMain -->
	</div><!--end: sideBar 侧边栏容器 -->
	<div class="clear"></div>
	</div><!--end: main -->
	<div class="clear"></div>
	<div id="footer">
		<!--done-->
Copyright &copy; 2020 我听过
<br /><span id="poweredby">Powered by .NET Core on Kubernetes</span>



	</div><!--end: footer -->
</div><!--end: home 自定义的最大容器 -->


    
</body>
</html>